import { pick } from '@antv/util';
import { Plot } from '../../core/plot';
import { DEFAULT_OPTIONS } from './constants';
import { ArcLayer } from '../../layers/arc-layer';
import { DotLayer } from '../../layers/dot-layer';
import { TextLayer } from '../../layers/text-layer';
import { LayerGroup } from '../../core/layer/layer-group';
export class Flow extends Plot {
    constructor() {
        super(...arguments);
        /**
         * 图表类型
         */
        this.type = Plot.PlotType.Flow;
    }
    /**
     * 获取默认配置
     */
    getDefaultOptions() {
        return Flow.DefaultOptions;
    }
    /**
     * 创建图层
     */
    createLayers(source) {
        this.flowLayer = new ArcLayer(Object.assign({ name: 'flowLayer', source }, pick(this.options, ArcLayer.LayerOptionsKeys)));
        const layerGroup = new LayerGroup([this.flowLayer]);
        if (this.options.radiation) {
            this.radiationLayer = this.createRadiationLayer(source);
            layerGroup.addLayer(this.radiationLayer);
        }
        if (this.options.label) {
            this.labelLayer = this.createLabelLayer(source, this.options.label);
            layerGroup.addLayer(this.labelLayer);
        }
        return layerGroup;
    }
    /**
     * 解析流向图起终点数据
     */
    parserPointData(source) {
        // const pointMap = {};
        const data = [];
        source.data.dataArray.forEach((item) => {
            const { coordinates } = item;
            // [startPoint, endPoint]
            const [, endPoint] = coordinates;
            // if (isUndefined(pointMap[startPoint.toString()])) {
            //   data.push({ ...item, coordinates: startPoint });
            //   pointMap[startPoint.toString()] = true;
            // }
            data.push(Object.assign(Object.assign({}, item), { coordinates: endPoint }));
        });
        return data;
    }
    /**
     * 创建辐射圈图层
     */
    createRadiationLayer(source) {
        const data = this.parserPointData(source);
        const { enabled = true, color, size = 20, shape = 'circle', animate = true } = this.options.radiation || {};
        const radiationLayer = new DotLayer({
            name: 'radiationLayer',
            source: {
                data,
                parser: { type: 'json', coordinates: 'coordinates' },
            },
            visible: enabled,
            color,
            size,
            shape,
            animate,
        });
        const updateCallback = () => {
            const data = this.parserPointData(this.source);
            radiationLayer.layer.setData(data);
        };
        source.on('update', updateCallback);
        radiationLayer.on('remove', () => {
            source.off('update', updateCallback);
        });
        return radiationLayer;
    }
    /**
     * 创建数据标签图层
     */
    createLabelLayer(source, label) {
        const data = this.parserPointData(source);
        const { visible, minZoom, maxZoom, zIndex = 0 } = this.options;
        const labelLayer = new TextLayer(Object.assign({ name: 'labelLayer', source: {
                data,
                parser: { type: 'json', coordinates: 'coordinates' },
            }, visible,
            minZoom,
            maxZoom, zIndex: zIndex + 0.1 }, label));
        const updateCallback = () => {
            const data = this.parserPointData(this.source);
            labelLayer.layer.setData(data);
        };
        source.on('update', updateCallback);
        labelLayer.on('remove', () => {
            source.off('update', updateCallback);
        });
        return labelLayer;
    }
    /**
     * 更新图层
     */
    updateLayers(options) {
        const flowLayerConfig = pick(options, ArcLayer.LayerOptionsKeys);
        this.flowLayer.update(flowLayerConfig);
        if (options.radiation) {
            if (this.radiationLayer) {
                const radiation = Object.assign(Object.assign({}, options.radiation), { visible: options.radiation.enabled });
                this.radiationLayer.update(radiation);
            }
            else {
                this.radiationLayer = this.createRadiationLayer(this.source);
                this.layerGroup.addLayer(this.radiationLayer);
            }
        }
        this.updateLabelLayer(this.source, options.label, this.options, this.labelLayer);
    }
    /**
     * 实现 legend 配置项
     */
    getLegendOptions() {
        const colorLegendItems = this.flowLayer.getColorLegendItems();
        if (colorLegendItems.length !== 0) {
            return { type: 'category', items: colorLegendItems };
        }
        return {};
    }
}
/**
 * 默认配置项
 */
Flow.DefaultOptions = DEFAULT_OPTIONS;
//# sourceMappingURL=index.js.map