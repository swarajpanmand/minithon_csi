import { __rest } from "tslib";
import { Source } from '@antv/l7';
import { Map } from '../map';
import { deepAssign } from '../../utils';
import { TextLayer } from '../../layers/text-layer';
import { PlotType } from '../../types';
import { MappingSource } from '../../adaptor/source';
import { isEqual } from '@antv/util';
import { getTheme } from '../../theme';
const DEFAULT_OPTIONS = {
    autoFit: false,
};
export class Plot extends Map {
    constructor(container, options) {
        if (typeof container === 'string' || container instanceof Element) {
            if (options === undefined) {
                throw new Error('options is undefined');
            }
            super(options);
            this.container = this.createContainer(container);
            this.theme = this.createTheme();
            this.scene = this.createScene();
            this.registerResources();
            this.initSource();
        }
        else {
            super(container);
        }
    }
    /**
     * 初始化数据
     */
    initSource() {
        this.source = this.createSource();
        this.render();
        this.inited = true;
    }
    /**
     * 初始化图层事件
     */
    initLayersEvent() {
        //
    }
    /**
     * 获取默认配置
     */
    getDefaultOptions() {
        return Plot.DefaultOptions;
    }
    /**
     * 创建 source 实例
     */
    createSource() {
        const _a = this.options.source, { data, aggregation } = _a, sourceCFG = __rest(_a, ["data", "aggregation"]);
        aggregation && MappingSource.aggregation(sourceCFG, aggregation);
        const source = new Source(data, sourceCFG);
        return source;
    }
    /**
     * 创建数据标签图层
     */
    createLabelLayer(source, label, plotLayerConfig) {
        const { visible, minZoom, maxZoom, zIndex = 0 } = plotLayerConfig || {};
        const textLayer = new TextLayer(Object.assign({ name: 'labelLayer', visible,
            minZoom,
            maxZoom, zIndex: zIndex + 0.1, source }, label));
        return textLayer;
    }
    /**
     * 更新数据标签图层
     */
    updateLabelLayer(source, label, plotLayerConfig, labelLayer) {
        if (label) {
            if (labelLayer) {
                labelLayer.update(Object.assign({}, label));
            }
            else {
                labelLayer = this.createLabelLayer(source, label, plotLayerConfig);
                this.layerGroup.addLayer(labelLayer);
            }
        }
        else if (label === false) {
            labelLayer && this.layerGroup.removeLayer(labelLayer);
        }
    }
    /**
     * 渲染
     */
    render() {
        const layerGroup = this.createLayers(this.source);
        if (this.inited) {
            this.layerGroup.removeAllLayer();
            layerGroup.addTo(this.scene);
            this.layerGroup = layerGroup;
            // this.scene.render();
        }
        else {
            this.layerGroup = layerGroup;
            if (this.scene['sceneService'].loaded) {
                this.onSceneLoaded();
            }
            else {
                this.scene.once('loaded', () => {
                    this.onSceneLoaded();
                });
            }
        }
        this.initLayersEvent();
    }
    /**
     * scene 加载成功回调
     */
    onSceneLoaded() {
        this.sceneLoaded = true;
        if (this.layerGroup.isEmpty()) {
            this.onLayersLoaded();
        }
        else {
            this.layerGroup.once('inited-all', () => {
                this.onLayersLoaded();
            });
        }
        this.layerGroup.addTo(this.scene);
    }
    /**
     * 图层加载成功回调
     */
    onLayersLoaded() {
        this.layersLoaded = true;
        this.initComponents();
        this.loaded = true;
        this.emit('loaded');
    }
    /**
     * 挂载到容器
     * 用于高级图表 L7Plot 挂载单个图表示例
     */
    attachToScene(scene, theme) {
        this.scene = scene;
        this.theme = theme ? theme : getTheme('default');
        this.registerResources();
        this.initSource();
    }
    /**
     * 取消挂载到容器上的 scene
     * 用于高级图表 L7Plot 挂载单个图表示例
     */
    unattachFromScene() {
        var _a;
        this.removeAllLayer();
        (_a = this.tooltip) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    /**
     * 添加到容器
     * 用于 L7 Scene 与图表混合使用场景
     */
    addToScene(scene) {
        this.attachToScene(scene);
    }
    /**
     * 从容器上移除
     * 用于 L7 Scene 与图表混合使用场景
     */
    removeFromScene() {
        var _a;
        this.removeAllLayer();
        this.removeScaleControl();
        this.removeZoomControl();
        this.removeLayerMenuControl();
        this.removeLegendControl();
        (_a = this.tooltip) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    /**
     * 更新: 更新配置且重新渲染
     */
    update(options) {
        this.updateOption(options);
        if (options.map && !isEqual(this.lastOptions.map, this.options.map)) {
            this.updateMap(options.map);
        }
        this.scene.setEnableRender(false);
        if (options.source && !isEqual(this.lastOptions.source, this.options.source)) {
            const _a = options.source, { data } = _a, sourceConfig = __rest(_a, ["data"]);
            this.changeData(data, sourceConfig);
        }
        // this.updateLayers(options);
        this.scene.setEnableRender(true);
        this.render();
        this.updateComponents();
        this.emit('update');
    }
    /**
     * 更新: 更新数据
     */
    changeData(data, cfg) {
        this.options.source = deepAssign({}, this.options.source, Object.assign({ data }, cfg));
        const _a = this.options.source, { aggregation } = _a, sourceCFG = __rest(_a, ["aggregation"]);
        aggregation && MappingSource.aggregation(sourceCFG, aggregation);
        this.source.setData(this.options.source.data, sourceCFG);
        // 更新 legend
        // TODO: 数据更新后，图层尚未执行更新，后续加图层 update 事件来解决
        const legend = this.options.legend;
        if (legend) {
            setTimeout(() => {
                this.updateLegendControl(legend);
            }, 500);
        }
        this.emit('change-data');
    }
}
/**
 * 默认的 options 配置项
 */
Plot.DefaultOptions = DEFAULT_OPTIONS;
/**
 * 地图图表类型
 */
Plot.PlotType = PlotType;
//# sourceMappingURL=index.js.map