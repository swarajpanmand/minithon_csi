import { __rest } from "tslib";
import { isEqual, isUndefined, pick } from '@antv/util';
import { Source } from '@antv/l7';
import EventEmitter from '@antv/event-emitter';
import { LayerType } from '../../types/layer';
import { MappingSource } from '../../adaptor/source';
import { LayerEventList } from '../map/constants';
import { deepAssign } from '../../utils';
const LayerConfigkeys = ['name', 'zIndex', 'visible', 'minZoom', 'maxZoom', 'pickingBuffer', 'autoFit', 'blend'];
export class PlotLayer extends EventEmitter {
    constructor(options) {
        super();
        this.options = deepAssign({}, this.getDefaultOptions(), options);
        this.lastOptions = this.options;
    }
    /**
     * 获取默认配置
     */
    getDefaultOptions() {
        return {};
    }
    pickLayerConfig(params) {
        const config = pick(params, LayerConfigkeys);
        return config;
    }
    addTo(scene) {
        scene.addLayer(this.layer);
    }
    remove(scene) {
        scene.removeLayer(this.layer);
    }
    /**
     * 更新
     */
    update(options) {
        this.updateOption(options);
        this.updateConfig(options);
    }
    /**
     * 更新: 更新配置
     */
    updateOption(options) {
        this.lastOptions = this.options;
        this.options = deepAssign({}, this.options, options);
    }
    // 更新: 更新图层属性配置
    updateConfig(options) {
        if (!isUndefined(options.zIndex) && !isEqual(this.lastOptions.zIndex, this.options.zIndex)) {
            this.setIndex(options.zIndex);
        }
        if (!isUndefined(options.blend) && !isEqual(this.lastOptions.blend, this.options.blend)) {
            this.setBlend(options.blend);
        }
        if (!isUndefined(options.minZoom) && !isEqual(this.lastOptions.minZoom, this.options.minZoom)) {
            this.setMinZoom(options.minZoom);
        }
        if (!isUndefined(options.maxZoom) && !isEqual(this.lastOptions.maxZoom, this.options.maxZoom)) {
            this.setMinZoom(options.maxZoom);
        }
        if (!isUndefined(options.visible) && !isEqual(this.lastOptions.visible, this.options.visible)) {
            options.visible ? this.show() : this.hide();
        }
    }
    render() {
        this.layer.renderLayers();
    }
    setSource(source) {
        if (source instanceof Source) {
            this.layer.setSource(source);
        }
        else {
            const { data, aggregation } = source, option = __rest(source, ["data", "aggregation"]);
            aggregation && MappingSource.aggregation(option, aggregation);
            const layerSource = this.layer.getSource();
            if (layerSource) {
                this.layer.setData(data, option);
            }
            else {
                this.layer.source(data, option);
            }
        }
    }
    changeData(source) {
        this.setSource(source);
    }
    setIndex(zIndex) {
        this.layer.setIndex(zIndex);
    }
    setBlend(blend) {
        this.layer.setBlend(blend);
    }
    setMinZoom(minZoom) {
        this.layer.setMinZoom(minZoom);
    }
    setMaxZoom(maxZoom) {
        this.layer.setMaxZoom(maxZoom);
    }
    show() {
        this.layer.inited && this.layer.show();
    }
    hide() {
        this.layer.inited && this.layer.hide();
    }
    toggleVisible() {
        this.isVisible() ? this.hide() : this.show();
    }
    isVisible() {
        return this.layer.inited ? this.layer.isVisible() : this.options.visible;
    }
    fitBounds(fitBoundsOptions) {
        this.layer.fitBounds(fitBoundsOptions);
    }
    /**
     * 事件代理: 绑定事件
     */
    on(name, callback) {
        if (LayerEventList.indexOf(name) !== -1) {
            this.layer.on(name, callback);
        }
        else {
            super.on(name, callback);
        }
        return this;
    }
    /**
     * 事件代理: 绑定一次事件
     */
    once(name, callback) {
        if (LayerEventList.indexOf(name) !== -1) {
            this.layer.once(name, callback);
        }
        else {
            super.once(name, callback);
        }
        return this;
    }
    /**
     * 事件代理: 解绑事件
     */
    off(name, callback) {
        if (LayerEventList.indexOf(name) !== -1) {
            this.layer.off(name, callback);
        }
        else {
            super.off(name, callback);
        }
        return this;
    }
}
/**
 * 地图图表类型
 */
PlotLayer.LayerType = LayerType;
/**
 * 图层属性配置项 Keys
 */
PlotLayer.LayerConfigkeys = LayerConfigkeys;
//# sourceMappingURL=plot-layer.js.map