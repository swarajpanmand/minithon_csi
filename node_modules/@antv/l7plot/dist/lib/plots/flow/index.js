"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Flow = void 0;
const util_1 = require("@antv/util");
const plot_1 = require("../../core/plot");
const constants_1 = require("./constants");
const arc_layer_1 = require("../../layers/arc-layer");
const dot_layer_1 = require("../../layers/dot-layer");
const text_layer_1 = require("../../layers/text-layer");
const layer_group_1 = require("../../core/layer/layer-group");
class Flow extends plot_1.Plot {
    constructor() {
        super(...arguments);
        /**
         * 图表类型
         */
        this.type = plot_1.Plot.PlotType.Flow;
    }
    /**
     * 获取默认配置
     */
    getDefaultOptions() {
        return Flow.DefaultOptions;
    }
    /**
     * 创建图层
     */
    createLayers(source) {
        this.flowLayer = new arc_layer_1.ArcLayer(Object.assign({ name: 'flowLayer', source }, (0, util_1.pick)(this.options, arc_layer_1.ArcLayer.LayerOptionsKeys)));
        const layerGroup = new layer_group_1.LayerGroup([this.flowLayer]);
        if (this.options.radiation) {
            this.radiationLayer = this.createRadiationLayer(source);
            layerGroup.addLayer(this.radiationLayer);
        }
        if (this.options.label) {
            this.labelLayer = this.createLabelLayer(source, this.options.label);
            layerGroup.addLayer(this.labelLayer);
        }
        return layerGroup;
    }
    /**
     * 解析流向图起终点数据
     */
    parserPointData(source) {
        // const pointMap = {};
        const data = [];
        source.data.dataArray.forEach((item) => {
            const { coordinates } = item;
            // [startPoint, endPoint]
            const [, endPoint] = coordinates;
            // if (isUndefined(pointMap[startPoint.toString()])) {
            //   data.push({ ...item, coordinates: startPoint });
            //   pointMap[startPoint.toString()] = true;
            // }
            data.push(Object.assign(Object.assign({}, item), { coordinates: endPoint }));
        });
        return data;
    }
    /**
     * 创建辐射圈图层
     */
    createRadiationLayer(source) {
        const data = this.parserPointData(source);
        const { enabled = true, color, size = 20, shape = 'circle', animate = true } = this.options.radiation || {};
        const radiationLayer = new dot_layer_1.DotLayer({
            name: 'radiationLayer',
            source: {
                data,
                parser: { type: 'json', coordinates: 'coordinates' },
            },
            visible: enabled,
            color,
            size,
            shape,
            animate,
        });
        const updateCallback = () => {
            const data = this.parserPointData(this.source);
            radiationLayer.layer.setData(data);
        };
        source.on('update', updateCallback);
        radiationLayer.on('remove', () => {
            source.off('update', updateCallback);
        });
        return radiationLayer;
    }
    /**
     * 创建数据标签图层
     */
    createLabelLayer(source, label) {
        const data = this.parserPointData(source);
        const { visible, minZoom, maxZoom, zIndex = 0 } = this.options;
        const labelLayer = new text_layer_1.TextLayer(Object.assign({ name: 'labelLayer', source: {
                data,
                parser: { type: 'json', coordinates: 'coordinates' },
            }, visible,
            minZoom,
            maxZoom, zIndex: zIndex + 0.1 }, label));
        const updateCallback = () => {
            const data = this.parserPointData(this.source);
            labelLayer.layer.setData(data);
        };
        source.on('update', updateCallback);
        labelLayer.on('remove', () => {
            source.off('update', updateCallback);
        });
        return labelLayer;
    }
    /**
     * 更新图层
     */
    updateLayers(options) {
        const flowLayerConfig = (0, util_1.pick)(options, arc_layer_1.ArcLayer.LayerOptionsKeys);
        this.flowLayer.update(flowLayerConfig);
        if (options.radiation) {
            if (this.radiationLayer) {
                const radiation = Object.assign(Object.assign({}, options.radiation), { visible: options.radiation.enabled });
                this.radiationLayer.update(radiation);
            }
            else {
                this.radiationLayer = this.createRadiationLayer(this.source);
                this.layerGroup.addLayer(this.radiationLayer);
            }
        }
        this.updateLabelLayer(this.source, options.label, this.options, this.labelLayer);
    }
    /**
     * 实现 legend 配置项
     */
    getLegendOptions() {
        const colorLegendItems = this.flowLayer.getColorLegendItems();
        if (colorLegendItems.length !== 0) {
            return { type: 'category', items: colorLegendItems };
        }
        return {};
    }
}
exports.Flow = Flow;
/**
 * 默认配置项
 */
Flow.DefaultOptions = constants_1.DEFAULT_OPTIONS;
//# sourceMappingURL=index.js.map